package itesm.mx.acbasic;/* Generated By:JavaCC: Do not edit this line. ACBasic.java */
import java.util.Stack;
import java.util.ArrayList;
import itesm.mx.acbasic.Data.Codigos;
import itesm.mx.acbasic.Data.Constante;
import itesm.mx.acbasic.Data.CuboSemantico;
import itesm.mx.acbasic.Data.DirectorioProcedimientos;
import itesm.mx.acbasic.Data.ManejadorMemoria;
import itesm.mx.acbasic.Data.Procedimiento;
import itesm.mx.acbasic.Data.Variable;

public class ACBasic implements ACBasicConstants {
    private static DirectorioProcedimientos dirProcedimientos;
    private static String procedimientoActual;
    private static Stack <Integer> pilaOperadores;
    private static Stack <Integer> pilaOperandos;
    private static Stack <Integer> pilaTipos;
    private static Stack <Integer> pilaSaltos;
    private static CuboSemantico cuboSemantico;
    private static int[][] matrizCuadruplos;
    private static int contadorCuadruplo;
    private static int direccionCuadruploMain;
    private static int contadorProcedimientos;

    public static void init(){
        pilaOperadores = new Stack<Integer>();
        pilaOperandos = new Stack<Integer>();
        pilaTipos = new Stack<Integer>();
        pilaSaltos = new Stack<Integer>();
        cuboSemantico = new CuboSemantico();
        matrizCuadruplos = new int[1000][4];
        contadorCuadruplo = 0;
        direccionCuadruploMain = 0;
        contadorProcedimientos = 0;
    }

    public static int[][] getMatrizCuadruplos(){
        return matrizCuadruplos;
    }

    public static int getContadorCuadruplo(){
        return contadorCuadruplo;
    }

    public static DirectorioProcedimientos getDirProcedimientos(){
        return dirProcedimientos;
    }

    static void errorHandler(int type, String detail) {
        switch (type){
            case 1:
                System.out.println("Error: Procedimiento repetido:" + detail);
                System.exit(0);
                break;
            case 2:
                System.out.println("Error: Variable repetida:" + detail);
                System.exit(0);
                break;
            case 3:
                System.out.println("Error: Parametro repetido:" + detail);
                System.exit(0);
                break;
            case 4:
                System.out.println("Error: ID no definido:" + detail);
                System.exit(0);
                break;
            case 5:
                System.out.println("Error: Tipos no coinciden:" + detail);
                System.exit(0);
                break;
            case 6:
                System.out.println("Error: Expresion no es booleana:" + detail);
                System.exit(0);
                break;
            case 7:
                System.out.println("Error: Argumentos no coinciden en:" + detail);
                System.exit(0);
                break;
            case 8:
                System.out.println("Error: Procedimiento void con valor de retorno tipo:" + detail);
                System.exit(0);
                break;
            case 9:
                System.out.println("Error: Procedimiento no void sin valor de retorno en:" + detail);
                System.exit(0);
                break;
            case 10:
                System.out.println("Error: Procedimiento con incorrecto tipo de retorno en:" + detail);
                System.exit(0);
                break;
            case 11:
                System.out.println("Error: Tama\u00f1o del procedimiento imposible:" + detail);
                System.exit(0);
                break;
            case 12:
                System.out.println("Error: Index del arreglo no es entero:" + detail);
                System.exit(0);
                break;
            case 13:
                System.out.println("Error: Constante de tipo diferente al arreglo:" + detail);
                System.exit(0);
                break;
            case 14:
                System.out.println("Error: Tama\u00f1o incorrecto en la declaracion del arreglo:" + detail);
                System.exit(0);
                break;
        }
    }

    static final public void prog() throws ParseException {
        Token idPrograma;
        jj_consume_token(PROGRAM);
        dirProcedimientos = new DirectorioProcedimientos();
        idPrograma = jj_consume_token(ID);
        // guardar el nombre del programa en el directorio de procedimientos
        dirProcedimientos.setNombrePrograma(idPrograma.toString());
        // guardar el id del procedimiento actual
        procedimientoActual = idPrograma.toString();
        // crear un objeto procedimiento auxiliar para guardar info del procedimiento program
        Procedimiento programProc = new Procedimiento();
        programProc.setNombreProcedimiento(idPrograma.toString());
        programProc.setTipoProcedimiento(Codigos.PROGRAM);
        programProc.setIdentificadorProcedimiento(-1);
        // guardar el procedimiento program en el directorio de procedimientos
        if (!dirProcedimientos.agregarProcedimiento(programProc)) {
            // si ya existe un procedimiento con ese nombre, reportar error
            errorHandler(1,idPrograma.toString());
        }
        jj_consume_token(PYC);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case VAR:
                vars();
                break;
            default:
                jj_la1[0] = jj_gen;
                ;
        }
        // guardar la direccion donde se debe generar el cuadruplo GOTO main
        direccionCuadruploMain = contadorCuadruplo;
        contadorCuadruplo++;
        label_1:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case FUNC:
                    ;
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    break label_1;
            }
            func();
        }
        main();
    }

    static final public int tipo() throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INT:
                jj_consume_token(INT);
            {if (true) return Codigos.INT;}
            break;
            case FLOAT:
                jj_consume_token(FLOAT);
            {if (true) return Codigos.FLOAT;}
            break;
            case CHAR:
                jj_consume_token(CHAR);
            {if (true) return Codigos.CHAR;}
            break;
            case STRING:
                jj_consume_token(STRING);
            {if (true) return Codigos.STRING;}
            break;
            case BOOL:
                jj_consume_token(BOOL);
            {if (true) return Codigos.BOOL;}
            break;
            default:
                jj_la1[2] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    static final public Constante cte() throws ParseException {
        Token valor; int tipo;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CTEI:
                valor = jj_consume_token(CTEI);
                tipo = Codigos.INT;
                break;
            case CTEF:
                valor = jj_consume_token(CTEF);
                tipo = Codigos.FLOAT;
                break;
            case TRUE:
                valor = jj_consume_token(TRUE);
                tipo = Codigos.BOOL;
                break;
            case FALSE:
                valor = jj_consume_token(FALSE);
                tipo = Codigos.BOOL;
                break;
            case CTESTR:
                valor = jj_consume_token(CTESTR);
                tipo = Codigos.STRING;
                break;
            case CTECHAR:
                valor = jj_consume_token(CTECHAR);
                tipo = Codigos.CHAR;
                break;
            default:
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        // agregar la constante al directorio de procedimientos si esta no existe ya

        if(dirProcedimientos.existeConstante(valor.toString())) {
            {if (true) return dirProcedimientos.getConstantePorValor(valor.toString());}
        } else {
            Constante auxiliar = new Constante(tipo, ManejadorMemoria.getMemoriaConstante(tipo) , valor.toString());
            dirProcedimientos.getConstantes().put(auxiliar.getDireccionConstante(), auxiliar);
            {if (true) return auxiliar;}
        }
        throw new Error("Missing return statement in function");
    }

    static final public void defarr(Variable arreglo) throws ParseException {
        Constante auxCte;
        //Lista para guardar los valores de cada casilla del arreglo
        ArrayList < Constante > auxListaCte = new ArrayList < Constante > ();
        jj_consume_token(CORIZQ);
        auxCte = cte();
        if(auxCte.getTipoConstante() == arreglo.getTipoVariable()){
            //guardar valor
            auxListaCte.add(auxCte);
        } else {
            //ERROR
            errorHandler(13,arreglo.getNombreVariable());
        }
        label_2:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case COMA:
                    ;
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    break label_2;
            }
            jj_consume_token(COMA);
            auxCte = cte();
            if(auxCte.getTipoConstante() == arreglo.getTipoVariable()){
                //guardar valor
                auxListaCte.add(auxCte);
            } else {
                //ERROR
                errorHandler(13,arreglo.getNombreVariable());
            }
        }
        jj_consume_token(CORDER);
        if(auxListaCte.size() != arreglo.getSizeVariable())
        {
            //ERROR
            errorHandler(14,arreglo.getNombreVariable());
        } else
        {
            for (int i = 0; i < arreglo.getSizeVariable(); i++){
                //generar cuadruplo
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.ASSIGN;
                matrizCuadruplos[contadorCuadruplo][1] = auxListaCte.get(i).getDireccionConstante();
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][3] = arreglo.getDireccionVariable() + i;
                contadorCuadruplo++;
            }
        }
    }

    static final public void vars() throws ParseException {
        jj_consume_token(VAR);
        // crear tabla de variables para el procedimiento actual si no existe
        if (dirProcedimientos.getProcedimientos().get(procedimientoActual).getVariables() == null){
            dirProcedimientos.getProcedimientos().get(procedimientoActual).crearTablaDeVariables();
        }
        vars1();
        jj_consume_token(PYC);
        label_3:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case INT:
                case CHAR:
                case FLOAT:
                case BOOL:
                case STRING:
                case ARRAY:
                    ;
                    break;
                default:
                    jj_la1[5] = jj_gen;
                    break label_3;
            }
            vars1();
            jj_consume_token(PYC);
        }
        dirProcedimientos.getProcedimientos().get(procedimientoActual).llenaTamanoVar();
    }

    static final public void vars1() throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INT:
            case CHAR:
            case FLOAT:
            case BOOL:
            case STRING:
                vars2();
                break;
            case ARRAY:
                vars3();
                break;
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    static final public void vars2() throws ParseException {
        int tipoVariable; Token nombreVariable; Constante cons;
        tipoVariable = tipo();
        nombreVariable = jj_consume_token(ID);
        // asignar el tipo de scope de la variable

        String scopeVar = "local";
        if (dirProcedimientos.getProcedimientos().get(procedimientoActual).getTipoProcedimiento() == Codigos.PROGRAM) {
            // unicamente si el procedimiento actual es de tipo program, el scope es global
            scopeVar = "global";
        }
        // crear objeto variable y darlo de alta en directorio de variables del procedimiento actual
        Variable varAuxiliar = new Variable(nombreVariable.toString(), tipoVariable, scopeVar);
        if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(varAuxiliar)){
            // si ya existe una variable en este directorio con el mismo nombre, reportar error
            errorHandler(2,nombreVariable.toString());
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IGUAL:
                jj_consume_token(IGUAL);
                cons = cte();
                int tipoRes = cuboSemantico.getCubo()[tipoVariable][cons.getTipoConstante()][Codigos.ASSIGN];
                // revisar si combinacion de tipos es permitida
                if(tipoRes != Codigos.ERROR) {
                    // generar cuadruplo
                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.ASSIGN;
                    matrizCuadruplos[contadorCuadruplo][1] = cons.getDireccionConstante();
                    matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][3] = varAuxiliar.getDireccionVariable();
                    contadorCuadruplo++;

                } else {
                    // ERROR
                    errorHandler(5, tipoVariable + " y " + cons.getTipoConstante());
                }
                break;
            default:
                jj_la1[7] = jj_gen;
                ;
        }
        label_4:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case COMA:
                    ;
                    break;
                default:
                    jj_la1[8] = jj_gen;
                    break label_4;
            }
            jj_consume_token(COMA);
            nombreVariable = jj_consume_token(ID);
            // crear objeto variable y darlo de alta en directorio de variables del procedimiento actual
            varAuxiliar = new Variable(nombreVariable.toString(), tipoVariable, scopeVar);
            if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(varAuxiliar)) {
                // si ya existe una variable en este directorio con el mismo nombre, reportar error
                errorHandler(2,nombreVariable.toString());
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case IGUAL:
                    jj_consume_token(IGUAL);
                    cons = cte();
                    int tipoRes = cuboSemantico.getCubo()[tipoVariable][cons.getTipoConstante()][Codigos.ASSIGN];
                    // revisar si combinacion de tipos es permitida
                    if(tipoRes != Codigos.ERROR) {
                        // generar cuadruplo
                        matrizCuadruplos[contadorCuadruplo][0] = Codigos.ASSIGN;
                        matrizCuadruplos[contadorCuadruplo][1] = cons.getDireccionConstante();
                        matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                        matrizCuadruplos[contadorCuadruplo][3] = varAuxiliar.getDireccionVariable();
                        contadorCuadruplo++;

                    } else {
                        // ERROR
                        errorHandler(5, tipoVariable + " y " + cons.getTipoConstante());
                    }
                    break;
                default:
                    jj_la1[9] = jj_gen;
                    ;
            }
        }
    }

    static final public void vars3() throws ParseException {
        int tipoArreglo; Token nombreArreglo; Token size;
        jj_consume_token(ARRAY);
        tipoArreglo = tipo();
        nombreArreglo = jj_consume_token(ID);
        // definir el scope de la variable
        String scope = "local";
        if(dirProcedimientos.getProcedimientos().get(procedimientoActual).getTipoProcedimiento() == Codigos.PROGRAM){
            // unicamente si el procedimiento actual es program, el scope de la variable es global
            scope = "global";
        }
        Variable auxArreglo = new Variable(nombreArreglo.toString(),tipoArreglo, scope);
        jj_consume_token(CORIZQ);
        size = jj_consume_token(CTEI);
        //Revisar size mayor a 0
        if(Integer.parseInt(size.toString()) > 0) {
            auxArreglo.setSizeVariable(Integer.parseInt(size.toString()));
        } else {
            //Error
            errorHandler(11,nombreArreglo.toString());
        }

        // dar de alta la variable en el directorio de variables del procedimiento actual
        if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(auxArreglo)){
            // si ya existe una variable con ese nombre, reportar error
            errorHandler(2,nombreArreglo.toString());
        }
        jj_consume_token(CORDER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IGUAL:
                jj_consume_token(IGUAL);
                defarr(auxArreglo);
                break;
            default:
                jj_la1[10] = jj_gen;
                ;
        }
    }

    static final public void func() throws ParseException {
        int tipoFuncion; Token nombreProc;
        jj_consume_token(FUNC);
        // crear un objeto procedimiento
        Procedimiento procAux = new Procedimiento();
        tipoFuncion = func1();
        // guardar el tipo de procedimiento
        procAux.setTipoProcedimiento(tipoFuncion);
        nombreProc = jj_consume_token(ID);
        // guardar el nombre del procedimiento en el objeto
        procAux.setNombreProcedimiento(nombreProc.toString());

        // guardar el identificador del procedimiento
        procAux.setIdentificadorProcedimiento(contadorProcedimientos);
        contadorProcedimientos++;

        // dar de alta el procedimiento en el directorio de procedimientos
        if (!dirProcedimientos.agregarProcedimiento(procAux)) {
            // reportar error si ya existe un procedimiento con este nombre
            errorHandler(1, nombreProc.toString());
        } else{
            // si se pudo guardar el procedimiento, asignar procedimientoActual con el id recien leido
            procedimientoActual = nombreProc.toString();
        }
        jj_consume_token(PARIZQ);
        param();
        jj_consume_token(PARDER);
        // guardar el cuadruplo inicial del procedimiento
        dirProcedimientos.getProcedimientos().get(procedimientoActual).setCuadruploInicial(contadorCuadruplo);
        body(tipoFuncion);
        // borrar tabla de variables para el procedimiento actual
        dirProcedimientos.getProcedimientos().get(procedimientoActual).setVariables(null);
        // generar cuadruplo retorno
        matrizCuadruplos[contadorCuadruplo][0] = Codigos.ENDPROC;
        matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][3] = Codigos.NULO;
        contadorCuadruplo++;
    }

    static final public int func1() throws ParseException {
        int tipoFuncion;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INT:
            case CHAR:
            case FLOAT:
            case BOOL:
            case STRING:
                tipoFuncion = tipo();
            {if (true) return tipoFuncion;}
            break;
            case VOID:
                jj_consume_token(VOID);
            {if (true) return Codigos.VOID;}
            break;
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        throw new Error("Missing return statement in function");
    }

    static final public void param() throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INT:
            case CHAR:
            case FLOAT:
            case BOOL:
            case STRING:
                param1();
                label_5:
                while (true) {
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case COMA:
                            ;
                            break;
                        default:
                            jj_la1[12] = jj_gen;
                            break label_5;
                    }
                    jj_consume_token(COMA);
                    param1();
                }
                break;
            default:
                jj_la1[13] = jj_gen;
                ;
        }
    }

    static final public void param1() throws ParseException {
        int tipoParam; Token nombreParam;
        tipoParam = tipo();
        // si el procedimiento actual no tiene ya un directorio de variables, crearlo
        if(dirProcedimientos.getProcedimientos().get(procedimientoActual).getVariables()==null){
            dirProcedimientos.getProcedimientos().get(procedimientoActual).crearTablaDeVariables();
        }
        // definir el primer parametro como NO por referencia (POR VALOR)
        dirProcedimientos.getProcedimientos().get(procedimientoActual).getIndicadorPorReferencia().add(false);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case AMP:
                jj_consume_token(AMP);
                // si lee un &, definir el parametro actual como POR REFERENCIA
                int size = dirProcedimientos.getProcedimientos().get(procedimientoActual).getIndicadorPorReferencia().size();
                dirProcedimientos.getProcedimientos().get(procedimientoActual).getIndicadorPorReferencia().set(size - 1, true);
                break;
            default:
                jj_la1[14] = jj_gen;
                ;
        }
        nombreParam = jj_consume_token(ID);
        // crear objeto variable y guardar el tipo y scope
        Variable paramAux = new Variable(nombreParam.toString(), tipoParam, "local");
        // dar de alta el parametro en el directorio de variables del procedimiento actual
        if(!dirProcedimientos.getProcedimientos().get(procedimientoActual).agregarVariable(paramAux)){
            // reportar error si ya existe una variable con ese nombre
            errorHandler(3, nombreParam.toString());
        } else {
            // guardar el tipo de parametro
            dirProcedimientos.getProcedimientos().get(procedimientoActual).getTipoParams().add(paramAux.getTipoVariable());
            // GUARDAR LA DIRECCION VIRTUAL DEL PARAMETRO
            dirProcedimientos.getProcedimientos().get(procedimientoActual).getDireccionParametros().add(paramAux.getDireccionVariable());
        }
    }

    static final public void body(int tipoFuncion) throws ParseException {
        boolean existeRetorno = false;
        jj_consume_token(LLAIZQ);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case VAR:
                vars();
                break;
            default:
                jj_la1[15] = jj_gen;
                ;
        }
        label_6:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case PRINT:
                case READ:
                case WHILE:
                case IF:
                case ID:
                    ;
                    break;
                default:
                    jj_la1[16] = jj_gen;
                    break label_6;
            }
            body1();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case RETURN:
                jj_consume_token(RETURN);
                // prender bandera
                existeRetorno = true;
                // revisar que funcion no sea tipo VOID
                if (tipoFuncion == Codigos.VOID)
                {
                    // ERROR
                    errorHandler(8, "");
                }
                exp();
                //revisar si el tipo de retorno coincide coincide con el tipo de funcion
                int valorRetorno = pilaOperandos.pop();
                int tipoRetorno = pilaTipos.pop();
                // revisar que los tipos coincidan
                if (tipoRetorno != tipoFuncion)
                {
                    // ERROR
                    errorHandler(10, ""+tipoRetorno);
                } else {
                    // generar cuadruplo RETURN

                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.RETURN;
                    matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][3] = valorRetorno;
                    contadorCuadruplo++;
                }
                jj_consume_token(PYC);
                break;
            default:
                jj_la1[17] = jj_gen;
                ;
        }
        jj_consume_token(LLADER);
        // revisar que si la funcion no es void, se haya hecho un return

        if (tipoFuncion != Codigos.VOID && tipoFuncion != Codigos.MAIN) {
            if (!existeRetorno) {
                // ERROR
                errorHandler(9, "");
            }
        }
    }

    static final public void body1() throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ID:
                assignllam();
                break;
            case IF:
                cond();
                break;
            case READ:
                read();
                break;
            case PRINT:
                write();
                break;
            case WHILE:
                cycle();
                break;
            default:
                jj_la1[18] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    static final public void minibody() throws ParseException {
        jj_consume_token(LLAIZQ);
        label_7:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case PRINT:
                case READ:
                case WHILE:
                case IF:
                case ID:
                    ;
                    break;
                default:
                    jj_la1[19] = jj_gen;
                    break label_7;
            }
            minibody1();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case RETURN:
                jj_consume_token(RETURN);
                exp();
                jj_consume_token(PYC);
                break;
            default:
                jj_la1[20] = jj_gen;
                ;
        }
        jj_consume_token(LLADER);
    }

    static final public void minibody1() throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ID:
                assignllam();
                break;
            case IF:
                cond();
                break;
            case READ:
                read();
                break;
            case PRINT:
                write();
                break;
            case WHILE:
                cycle();
                break;
            default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    static final public void assign(Variable varArreglo) throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CORIZQ:
                jj_consume_token(CORIZQ);
                exp();
                int tipoIndex = pilaTipos.pop();
                int valorIndex = pilaOperandos.pop();

                if(tipoIndex != Codigos.INT){
                    //Error
                    errorHandler(12,varArreglo.getNombreVariable());
                } else {
                    // generar cuadruplo VERIFICA
                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.VERIFICAR;
                    matrizCuadruplos[contadorCuadruplo][1] = valorIndex;
                    matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][3] = varArreglo.getSizeVariable();
                    contadorCuadruplo++;
                    // GENERAR CUADRUPLO DE SUMA OFFSET + DIRBASE
                    int direccionResArr = ManejadorMemoria.getMemoriaTemporal(varArreglo.getTipoVariable());
                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.SUMAOFFSET;
                    matrizCuadruplos[contadorCuadruplo][1] = valorIndex;
                    matrizCuadruplos[contadorCuadruplo][2] = varArreglo.getDireccionVariable();
                    matrizCuadruplos[contadorCuadruplo][3] = direccionResArr;
                    contadorCuadruplo++;
                    // GUARDAR LA DIRECCION INDIRECTA COMO NUMERO NEGATIVO
                    pilaOperandos.push(direccionResArr *  -1);
                    pilaTipos.push(varArreglo.getTipoVariable());
                }
                jj_consume_token(CORDER);
                break;
            default:
                jj_la1[22] = jj_gen;
                ;
        }
        jj_consume_token(IGUAL);
        // meter operador de asignacion a operadores
        pilaOperadores.push(Codigos.ASSIGN);
        exp();
        int operador = pilaOperadores.pop();
        int operando2 = pilaOperandos.pop();
        int operando1 = pilaOperandos.pop();
        int tipo2 = pilaTipos.pop();
        int tipo1 = pilaTipos.pop();
        int tipoRes = cuboSemantico.getCubo()[tipo1][tipo2][operador];
        // revisar si combinacion de tipos es permitida
        if(tipoRes != Codigos.ERROR) {
            // generar cuadruplo
            matrizCuadruplos[contadorCuadruplo][0] = operador;
            matrizCuadruplos[contadorCuadruplo][1] = operando2;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][3] = operando1;
            contadorCuadruplo++;

        } else {
            // ERROR
            errorHandler(5, tipo1 + " y " +tipo2);
        }
        jj_consume_token(PYC);
    }

    static final public void exp() throws ParseException {
        e1();
        // revisar si el tope es AND u OR
        if (!pilaOperadores.empty()) {
            if (pilaOperadores.peek()== Codigos.AND || pilaOperadores.peek()== Codigos.OR) {
                int operador = pilaOperadores.pop();
                int operando2 = pilaOperandos.pop();
                int operando1 = pilaOperandos.pop();
                int tipo2 = pilaTipos.pop();
                int tipo1 = pilaTipos.pop();
                int tipoRes = cuboSemantico.getCubo()[tipo1][tipo2][Codigos.OPLOGIC];
                // revisar si combinacion de tipos es permitida
                if(tipoRes != Codigos.ERROR) {
                    // generar cuadruplo
                    matrizCuadruplos[contadorCuadruplo][0] = operador;
                    matrizCuadruplos[contadorCuadruplo][1] = operando1;
                    matrizCuadruplos[contadorCuadruplo][2] = operando2;
                    int direccionRes = ManejadorMemoria.getMemoriaTemporal(tipoRes);
                    matrizCuadruplos[contadorCuadruplo][3] = direccionRes;
                    contadorCuadruplo++;
                    //guardar resultado en pila operandos
                    pilaOperandos.push(direccionRes);
                    pilaTipos.push(tipoRes);
                    // agregar al tamaño de procedimiento un temporal
                    dirProcedimientos.getProcedimientos().get(procedimientoActual).getTamano().setTamanoTemp(tipoRes);
                } else {
                    // ERROR
                    errorHandler(5, tipo1 + " y " +tipo2);
                }
            }
        }
        label_8:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case AND:
                case OR:
                    ;
                    break;
                default:
                    jj_la1[23] = jj_gen;
                    break label_8;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case AND:
                    jj_consume_token(AND);
                    pilaOperadores.push(Codigos.AND);
                    break;
                case OR:
                    jj_consume_token(OR);
                    pilaOperadores.push(Codigos.OR);
                    break;
                default:
                    jj_la1[24] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            exp();
        }
    }

    static final public void e1() throws ParseException {
        e2();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case MAYOR:
            case MENOR:
            case MENORIG:
            case MAYORIG:
            case IGUALIG:
            case DIFERENTE:
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case MENOR:
                        jj_consume_token(MENOR);
                        pilaOperadores.push(Codigos.MENOR);
                        break;
                    case MAYOR:
                        jj_consume_token(MAYOR);
                        pilaOperadores.push(Codigos.MAYOR);
                        break;
                    case MENORIG:
                        jj_consume_token(MENORIG);
                        pilaOperadores.push(Codigos.MENORIG);
                        break;
                    case MAYORIG:
                        jj_consume_token(MAYORIG);
                        pilaOperadores.push(Codigos.MAYORIG);
                        break;
                    case IGUALIG:
                        jj_consume_token(IGUALIG);
                        pilaOperadores.push(Codigos.IGUAL);
                        break;
                    case DIFERENTE:
                        jj_consume_token(DIFERENTE);
                        pilaOperadores.push(Codigos.DIFERENTE);
                        break;
                    default:
                        jj_la1[25] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                e2();
                // revisar si el tope es operador relacional

                if (!pilaOperadores.empty())
                {
                    if (pilaOperadores.peek()== Codigos.MENOR || pilaOperadores.peek()== Codigos.MAYOR
                            || pilaOperadores.peek()== Codigos.MENORIG || pilaOperadores.peek()== Codigos.MAYORIG
                            || pilaOperadores.peek()== Codigos.IGUAL || pilaOperadores.peek()== Codigos.DIFERENTE){
                        int operador = pilaOperadores.pop();
                        int operando2 = pilaOperandos.pop();
                        int operando1 = pilaOperandos.pop();
                        int tipo2 = pilaTipos.pop();
                        int tipo1 = pilaTipos.pop();
                        int tipoRes = cuboSemantico.getCubo()[tipo1][tipo2][Codigos.OPREL];
                        // revisar si combinacion de tipos es permitida
                        if(tipoRes != Codigos.ERROR) {
                            // generar cuadruplo
                            matrizCuadruplos[contadorCuadruplo][0] = operador;
                            matrizCuadruplos[contadorCuadruplo][1] = operando1;
                            matrizCuadruplos[contadorCuadruplo][2] = operando2;
                            int direccionRes = ManejadorMemoria.getMemoriaTemporal(tipoRes);
                            matrizCuadruplos[contadorCuadruplo][3] = direccionRes;
                            contadorCuadruplo++;
                            //guardar resultado en pila operandos
                            pilaOperandos.push(direccionRes);
                            pilaTipos.push(tipoRes);
                            // agregar al tamaño de procedimiento un temporal
                            dirProcedimientos.getProcedimientos().get(procedimientoActual).getTamano().setTamanoTemp(tipoRes);
                        } else {
                            // ERROR
                            errorHandler(5, tipo1 + " y " +tipo2);
                        }
                    }
                }
                break;
            default:
                jj_la1[26] = jj_gen;
                ;
        }
    }

    static final public void e2() throws ParseException {
        term();
        // revisar si el tope es + o -
        if (!pilaOperadores.empty()) {
            if (pilaOperadores.peek()== Codigos.SUMA || pilaOperadores.peek()== Codigos.RESTA) {
                int operador = pilaOperadores.pop();
                int operando2 = pilaOperandos.pop();
                int operando1 = pilaOperandos.pop();
                int tipo2 = pilaTipos.pop();
                int tipo1 = pilaTipos.pop();
                int tipoRes = cuboSemantico.getCubo()[tipo1][tipo2][operador];
                // revisar si combinacion de tipos es permitida
                if(tipoRes != Codigos.ERROR) {
                    // generar cuadruplo
                    matrizCuadruplos[contadorCuadruplo][0] = operador;
                    matrizCuadruplos[contadorCuadruplo][1] = operando1;
                    matrizCuadruplos[contadorCuadruplo][2] = operando2;
                    int direccionRes = ManejadorMemoria.getMemoriaTemporal(tipoRes);
                    matrizCuadruplos[contadorCuadruplo][3] = direccionRes;
                    contadorCuadruplo++;
                    //guardar resultado en pila operandos
                    pilaOperandos.push(direccionRes);
                    pilaTipos.push(tipoRes);
                    // agregar al tamaño de procedimiento un temporal
                    dirProcedimientos.getProcedimientos().get(procedimientoActual).getTamano().setTamanoTemp(tipoRes);
                } else {
                    // ERROR
                    errorHandler(5, tipo1 + " y " +tipo2);
                }
            }
        }
        label_9:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case MAS:
                case MENOS:
                    ;
                    break;
                default:
                    jj_la1[27] = jj_gen;
                    break label_9;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case MAS:
                    jj_consume_token(MAS);
                    pilaOperadores.push(Codigos.SUMA);
                    break;
                case MENOS:
                    jj_consume_token(MENOS);
                    pilaOperadores.push(Codigos.RESTA);
                    break;
                default:
                    jj_la1[28] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            e2();
        }
    }

    static final public void term() throws ParseException {
        fact();
        // revisar si el tope es * o /

        if (!pilaOperadores.empty()) {

            if (pilaOperadores.peek()== Codigos.MULT || pilaOperadores.peek()== Codigos.DIV) {
                int operador = pilaOperadores.pop();
                int operando2 = pilaOperandos.pop();
                int operando1 = pilaOperandos.pop();
                int tipo2 = pilaTipos.pop();
                int tipo1 = pilaTipos.pop();
                int tipoRes = cuboSemantico.getCubo()[tipo1][tipo2][operador];
                // revisar si combinacion de tipos es permitida
                if(tipoRes != Codigos.ERROR) {
                    // generar cuadruplo
                    matrizCuadruplos[contadorCuadruplo][0] = operador;
                    matrizCuadruplos[contadorCuadruplo][1] = operando1;
                    matrizCuadruplos[contadorCuadruplo][2] = operando2;
                    int direccionRes = ManejadorMemoria.getMemoriaTemporal(tipoRes);
                    matrizCuadruplos[contadorCuadruplo][3] = direccionRes;
                    contadorCuadruplo++;
                    //guardar resultado en pila operandos
                    pilaOperandos.push(direccionRes);
                    pilaTipos.push(tipoRes);
                    // agregar al tamaño de procedimiento un temporal
                    dirProcedimientos.getProcedimientos().get(procedimientoActual).getTamano().setTamanoTemp(tipoRes);
                } else {
                    // ERROR
                    errorHandler(5, tipo1 + " y " + tipo2);
                }
            }
        }
        label_10:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case POR:
                case ENTRE:
                    ;
                    break;
                default:
                    jj_la1[29] = jj_gen;
                    break label_10;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case POR:
                    jj_consume_token(POR);
                    pilaOperadores.push(Codigos.MULT);
                    break;
                case ENTRE:
                    jj_consume_token(ENTRE);
                    pilaOperadores.push(Codigos.DIV);
                    break;
                default:
                    jj_la1[30] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            term();
        }
    }

    static final public void fact() throws ParseException {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case NEGACION:
                jj_consume_token(NEGACION);
                // agregar el NOT a la pila de operadores
                pilaOperadores.push(Codigos.NOT);
                break;
            default:
                jj_la1[31] = jj_gen;
                ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TRUE:
            case FALSE:
            case CTEI:
            case CTEF:
            case CTESTR:
            case CTECHAR:
                fact1();
                break;
            case PARIZQ:
                fact2();
                break;
            case ID:
                fact3();
                break;
            default:
                jj_la1[32] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        // si el tope de la pila de operadores es NOT, generar cuadruplo

        if (!pilaOperadores.isEmpty()){
            if (pilaOperadores.peek()==Codigos.NOT) {
                int operador = pilaOperadores.pop();
                int operando = pilaOperandos.pop();
                int tipo = pilaTipos.pop();
                if (tipo == Codigos.BOOL) {
                    // generar cuadruplo
                    matrizCuadruplos[contadorCuadruplo][0] = operador;
                    matrizCuadruplos[contadorCuadruplo][1] = operando;
                    matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                    int direccionRes = ManejadorMemoria.getMemoriaTemporal(tipo);
                    matrizCuadruplos[contadorCuadruplo][3] = direccionRes;
                    contadorCuadruplo++;
                    //guardar resultado en pila operandos
                    pilaOperandos.push(direccionRes);
                    pilaTipos.push(tipo);
                    // agregar al tamaño de procedimiento un temporal
                    dirProcedimientos.getProcedimientos().get(procedimientoActual).getTamano().setTamanoTemp(tipo);
                }
            }
        }
    }

    static final public void fact1() throws ParseException {
        Constante cons;
        cons = cte();
        // meter a la pila de operandos la direccion de la constante y a la pila de tipos el tipo de la constante
        pilaOperandos.push(cons.getDireccionConstante());
        pilaTipos.push(cons.getTipoConstante());
    }

    static final public void fact2() throws ParseException {
        jj_consume_token(PARIZQ);
        // meter a pila fondo falso
        pilaOperadores.push(Codigos.FONDOFALSO);
        exp();
        jj_consume_token(PARDER);
        // sacar fondo falso
        pilaOperadores.pop();
    }

    static final public void fact3() throws ParseException {
        Token id;
        id = jj_consume_token(ID);
        // buscar que exista el id
        Variable varActual = dirProcedimientos.obtenerVariable(procedimientoActual, id.toString());
        if ( varActual != null) {
            //revisar que la variable no sea un arreglo
            if(varActual.getSizeVariable() == 0){
                // meter direccion y tipo a las pilas
                pilaOperandos.push(varActual.getDireccionVariable());
                pilaTipos.push(varActual.getTipoVariable());
            }
        } else {
            // revisar si el id es un metodo
            if (!dirProcedimientos.getProcedimientos().containsKey(id.toString())) {
                // ERROR
                errorHandler(4,id.toString());
            }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CORIZQ:
            case PARIZQ:
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case CORIZQ:
                        fact4(id.toString());
                        break;
                    case PARIZQ:
                        fact5(id.toString());
                        break;
                    default:
                        jj_la1[33] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[34] = jj_gen;
                ;
        }
    }

    static final public void fact4(String id) throws ParseException {
        jj_consume_token(CORIZQ);
        exp();
        int tipoIndex = pilaTipos.pop();
        int valorIndex = pilaOperandos.pop();
        if(tipoIndex != Codigos.INT){
            //Error
            errorHandler(12,id);
        } else {
            Variable varArreglo = dirProcedimientos.obtenerVariable(procedimientoActual, id.toString());
            // generar cuadruplo VERIFICA
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.VERIFICAR;
            matrizCuadruplos[contadorCuadruplo][1] = valorIndex;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][3] = varArreglo.getSizeVariable();
            contadorCuadruplo++;
            // GENERAR CUADRUPLO DE SUMA OFFSET + DIRBASE
            int direccionResArr = ManejadorMemoria.getMemoriaTemporal(varArreglo.getTipoVariable());
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.SUMAOFFSET;
            matrizCuadruplos[contadorCuadruplo][1] = valorIndex;
            matrizCuadruplos[contadorCuadruplo][2] = varArreglo.getDireccionVariable();
            matrizCuadruplos[contadorCuadruplo][3] = direccionResArr;
            contadorCuadruplo++;
            // GUARDAR LA DIRECCION INDIRECTA COMO NUMERO NEGATIVO
            pilaOperandos.push(direccionResArr *  -1);
            pilaTipos.push(varArreglo.getTipoVariable());
        }
        jj_consume_token(CORDER);
    }

    static final public void fact5(String nombreProc) throws ParseException {
        ArrayList<Integer > argumentosParam; ArrayList<Integer > tiposParam;
        jj_consume_token(PARIZQ);
        // agregar fondo falso
        pilaOperadores.push(Codigos.FONDOFALSO);

        // generar cuadruplo ERA
        matrizCuadruplos[contadorCuadruplo][0] = Codigos.ERA;
        matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][3] = dirProcedimientos.getProcedimientos().get(nombreProc).getIdentificadorProcedimiento();
        contadorCuadruplo++;
        // inicializar listas
        tiposParam = new ArrayList<Integer >();
        argumentosParam = new ArrayList<Integer >();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TRUE:
            case FALSE:
            case PARIZQ:
            case NEGACION:
            case ID:
            case CTEI:
            case CTEF:
            case CTESTR:
            case CTECHAR:
                exp();
                // guardar la direccion del argumento y su tipo para su futura comparacion
                argumentosParam.add( pilaOperandos.pop());
                tiposParam.add( pilaTipos.pop());
                label_11:
                while (true) {
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case COMA:
                            ;
                            break;
                        default:
                            jj_la1[35] = jj_gen;
                            break label_11;
                    }
                    jj_consume_token(COMA);
                    exp();
                    // guardar la direccion del argumento y su tipo para su futura comparacion
                    argumentosParam.add( pilaOperandos.pop());
                    tiposParam.add( pilaTipos.pop());
                }
                break;
            default:
                jj_la1[36] = jj_gen;
                ;
        }
        jj_consume_token(PARDER);
        // quitar fondo falso
        pilaOperadores.pop();

        // revisar que los tipos de la llamada coincidan con los parametros de la funcion

        if(dirProcedimientos.getProcedimientos().get(nombreProc).comparaParams(tiposParam) ){
            // generar cuadruplos de parametros
            for (int i=0; i< argumentosParam.size(); i++){
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.PARAM;
                matrizCuadruplos[contadorCuadruplo][1] = argumentosParam.get(i);
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][3] = i;
                contadorCuadruplo++;
            }
            // generar cuadruplo de GOSUB
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOSUB;
            matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][3] = dirProcedimientos.getProcedimientos().get(nombreProc).getIdentificadorProcedimiento();
            contadorCuadruplo++;

            // obtener el tipo de la funcion llamada para generar cuadruplo de asignacion si no es void

            int tipoFuncLlamada = dirProcedimientos.getProcedimientos().get(nombreProc).getTipoProcedimiento();
            if (tipoFuncLlamada != Codigos.VOID) {
                // generar cuadruplo de asignacion especial si la funcion llamada no es void
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.ASSIGNRET;
                matrizCuadruplos[contadorCuadruplo][1] = dirProcedimientos.getProcedimientos().get(nombreProc).getIdentificadorProcedimiento();
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][3] = ManejadorMemoria.getMemoriaTemporal(tipoFuncLlamada);
                contadorCuadruplo++;

                // agregar al tamaño de procedimiento un temporal
                dirProcedimientos.getProcedimientos().get(procedimientoActual).getTamano().setTamanoTemp(tipoFuncLlamada);

                // meter a pila de operadores y operandos los valores recien calculados
                pilaOperandos.push(matrizCuadruplos[contadorCuadruplo-1][3]);
                pilaTipos.push(tipoFuncLlamada);

            }

        } else {
            // ERROR LLAMADA
            errorHandler(7,nombreProc);
        }
    }

    static final public void cond() throws ParseException {
        jj_consume_token(IF);
        jj_consume_token(PARIZQ);
        exp();
        jj_consume_token(PARDER);
        // agregar a pila de saltos fondo falso para delimitar esta condicion
        pilaSaltos.push(Codigos.FONDOFALSOIF);

        int auxTipo = pilaTipos.pop();
        if (auxTipo != Codigos.BOOL){
            // ERROR
            errorHandler(6, "" + auxTipo);
        } else {
            int direccionRes = pilaOperandos.pop();
            // generar cuadruplo gotof
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOTOF;
            matrizCuadruplos[contadorCuadruplo][1] = direccionRes;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            contadorCuadruplo++;
            pilaSaltos.push(contadorCuadruplo-1);
        }
        minibody();
        label_12:
        while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case ELIF:
                    ;
                    break;
                default:
                    jj_la1[37] = jj_gen;
                    break label_12;
            }
            jj_consume_token(ELIF);
            // generar cuadruplo goto
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOTO;
            matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            contadorCuadruplo++;
            int falso = pilaSaltos.pop();
            matrizCuadruplos[falso][3] = contadorCuadruplo;
            pilaSaltos.push(contadorCuadruplo-1);
            jj_consume_token(PARIZQ);
            exp();
            jj_consume_token(PARDER);
            auxTipo = pilaTipos.pop();
            if (auxTipo != Codigos.BOOL){
                // ERROR
                errorHandler(6, "" + auxTipo);
            } else {
                int direccionRes = pilaOperandos.pop();
                // generar cuadruplo gotof
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOTOF;
                matrizCuadruplos[contadorCuadruplo][1] = direccionRes;
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                contadorCuadruplo++;
                pilaSaltos.push(contadorCuadruplo-1);
            }
            minibody();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ELSE:
                jj_consume_token(ELSE);
                // generar cuadruplo goto
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOTO;
                matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                contadorCuadruplo++;
                int falso = pilaSaltos.pop();
                matrizCuadruplos[falso][3] = contadorCuadruplo;
                pilaSaltos.push(contadorCuadruplo-1);
                minibody();
                break;
            default:
                jj_la1[38] = jj_gen;
                ;
        }
        while (pilaSaltos.peek() != Codigos.FONDOFALSOIF)
        {
            int fin = pilaSaltos.pop();
            matrizCuadruplos[fin][3] = contadorCuadruplo;
        }
        pilaSaltos.pop();
    }

    static final public void write() throws ParseException {
        jj_consume_token(PRINT);
        jj_consume_token(PARIZQ);
        exp();
        int resultado = pilaOperandos.pop();
        // POP PILA TIPOS
        // generar cuadruplo de print
        matrizCuadruplos[contadorCuadruplo][0] = Codigos.PRINT;
        matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][3] = resultado;
        contadorCuadruplo++;
        jj_consume_token(PARDER);
        jj_consume_token(PYC);
    }

    static final public void read() throws ParseException {
        Token id; Boolean arregloLeido = false;
        jj_consume_token(READ);
        jj_consume_token(PARIZQ);
        id = jj_consume_token(ID);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CORIZQ:
                jj_consume_token(CORIZQ);
                arregloLeido = true;
                exp();
                jj_consume_token(CORDER);
                int tipoIndex = pilaTipos.pop();
                int valorIndex = pilaOperandos.pop();
                if(tipoIndex != Codigos.INT){
                    //Error
                    errorHandler(12,id.toString());
                } else {
                    Variable varArreglo = dirProcedimientos.obtenerVariable(procedimientoActual, id.toString());
                    // generar cuadruplo VERIFICA
                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.VERIFICAR;
                    matrizCuadruplos[contadorCuadruplo][1] = valorIndex;
                    matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][3] = varArreglo.getSizeVariable();
                    contadorCuadruplo++;
                    // GENERAR CUADRUPLO DE SUMA OFFSET + DIRBASE
                    int direccionResArr = ManejadorMemoria.getMemoriaTemporal(varArreglo.getTipoVariable());
                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.SUMAOFFSET;
                    matrizCuadruplos[contadorCuadruplo][1] = valorIndex;
                    matrizCuadruplos[contadorCuadruplo][2] = varArreglo.getDireccionVariable();
                    matrizCuadruplos[contadorCuadruplo][3] = direccionResArr;
                    contadorCuadruplo++;

                    // generar cuadruplo de read

                    matrizCuadruplos[contadorCuadruplo][0] = Codigos.READ;
                    matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                    matrizCuadruplos[contadorCuadruplo][3] = direccionResArr *  -1;
                    contadorCuadruplo++;
                }
                break;
            default:
                jj_la1[39] = jj_gen;
                ;
        }
        jj_consume_token(PARDER);
        if (!arregloLeido)  {
            // buscar que exista el id
            Variable varActual = dirProcedimientos.obtenerVariable(procedimientoActual, id.toString());
            if ( varActual == null) {
                // ERROR
                errorHandler(4, id.toString());
            } else {
                // generar cuadruplo de read
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.READ;
                matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][3] = varActual.getDireccionVariable();
                contadorCuadruplo++;
            }
        }
        jj_consume_token(PYC);
    }

    static final public void cycle() throws ParseException {
        jj_consume_token(WHILE);
        pilaSaltos.push(contadorCuadruplo);
        jj_consume_token(PARIZQ);
        exp();
        jj_consume_token(PARDER);
        int auxTipo = pilaTipos.pop();
        if (auxTipo != Codigos.BOOL){
            // ERROR
            errorHandler(6, "" + auxTipo);
        } else {
            int direccionRes = pilaOperandos.pop();
            // generar cuadruplo gotof
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOTOF;
            matrizCuadruplos[contadorCuadruplo][1] = direccionRes;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            contadorCuadruplo++;
            pilaSaltos.push(contadorCuadruplo-1);
        }
        minibody();
        int falso = pilaSaltos.pop();
        int retorno = pilaSaltos.pop();
        // generar cuadruplo goto
        matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOTO;
        matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][3] = retorno;
        contadorCuadruplo++;
        //rellenar falso con contador
        matrizCuadruplos[falso][3] = contadorCuadruplo;
    }

    static final public void llam(String nombreProc) throws ParseException {
        ArrayList<Integer > argumentosParam; ArrayList<Integer > tiposParam;
        jj_consume_token(PARIZQ);
        // generar cuadruplo ERA
        matrizCuadruplos[contadorCuadruplo][0] = Codigos.ERA;
        matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
        matrizCuadruplos[contadorCuadruplo][3] = dirProcedimientos.getProcedimientos().get(nombreProc).getIdentificadorProcedimiento();
        contadorCuadruplo++;
        // inicializar listas
        tiposParam = new ArrayList<Integer >();
        argumentosParam = new ArrayList<Integer >();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TRUE:
            case FALSE:
            case PARIZQ:
            case NEGACION:
            case ID:
            case CTEI:
            case CTEF:
            case CTESTR:
            case CTECHAR:
                exp();
                // guardar la direccion del argumento y su tipo para su futura comparacion
                argumentosParam.add( pilaOperandos.pop());
                tiposParam.add( pilaTipos.pop());
                label_13:
                while (true) {
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                        case COMA:
                            ;
                            break;
                        default:
                            jj_la1[40] = jj_gen;
                            break label_13;
                    }
                    jj_consume_token(COMA);
                    exp();
                    // guardar la direccion del argumento y su tipo para su futura comparacion
                    argumentosParam.add( pilaOperandos.pop());
                    tiposParam.add( pilaTipos.pop());
                }
                break;
            default:
                jj_la1[41] = jj_gen;
                ;
        }
        jj_consume_token(PARDER);
        // revisar que los tipos de la llamada coincidan con los parametros de la funcion

        if(dirProcedimientos.getProcedimientos().get(nombreProc).comparaParams(tiposParam) ){
            // generar cuadruplos de parametros
            for (int i=0; i< argumentosParam.size(); i++){
                matrizCuadruplos[contadorCuadruplo][0] = Codigos.PARAM;
                matrizCuadruplos[contadorCuadruplo][1] = argumentosParam.get(i);
                matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
                matrizCuadruplos[contadorCuadruplo][3] = i;
                contadorCuadruplo++;
            }
            // agregar al procedimiento llamado las direcciones de los argumentos para usarlos si alguno es por referencia
            dirProcedimientos.getProcedimientos().get(nombreProc).getFilaDireccionesLlamada().add(argumentosParam);

            // generar cuadruplo de GOSUB
            matrizCuadruplos[contadorCuadruplo][0] = Codigos.GOSUB;
            matrizCuadruplos[contadorCuadruplo][1] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][2] = Codigos.NULO;
            matrizCuadruplos[contadorCuadruplo][3] = dirProcedimientos.getProcedimientos().get(nombreProc).getIdentificadorProcedimiento();
            contadorCuadruplo++;

        } else {
            // ERROR LLAMADA
            errorHandler(7,nombreProc);
        }
        jj_consume_token(PYC);
    }

    static final public void main() throws ParseException {
        jj_consume_token(MAIN);
        // crear cuadruplo GOTO main
        matrizCuadruplos[direccionCuadruploMain][0] = Codigos.GOTO;
        matrizCuadruplos[direccionCuadruploMain][1] = Codigos.NULO;
        matrizCuadruplos[direccionCuadruploMain][2] = Codigos.NULO;
        matrizCuadruplos[direccionCuadruploMain][3] = contadorCuadruplo;

        // asignar procedimientoActual a main
        procedimientoActual ="main";
        // crear el procedimiento Main con nombre y tipo
        Procedimiento mainProc = new Procedimiento();
        mainProc.setNombreProcedimiento("main");
        mainProc.setTipoProcedimiento(Codigos.MAIN);
        mainProc.setIdentificadorProcedimiento(-2);

        // dar de alta el proc main en directorio de procedimientos
        dirProcedimientos.agregarProcedimiento(mainProc);
        jj_consume_token(PARIZQ);
        jj_consume_token(PARDER);
        body(Codigos.MAIN);
    }

    static final public void assignllam() throws ParseException {
        Token id; Variable varActual;
        id = jj_consume_token(ID);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case PARIZQ:
                llam(id.toString());
                break;
            case CORIZQ:
            case IGUAL:
                // buscar que exista el id
                varActual = dirProcedimientos.obtenerVariable(procedimientoActual, id.toString());
                if ( varActual == null) {
                    // ERROR
                    errorHandler(4, id.toString());
                } else {
                    if (varActual.getSizeVariable() == 0 ){
                        // meter direccion y tipo a las pilas si no es un arreglo
                        pilaOperandos.push(varActual.getDireccionVariable());
                        pilaTipos.push(varActual.getTipoVariable());
                    }
                }
                assign(varActual);
                break;
            default:
                jj_la1[42] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    static private boolean jj_initialized_once = false;
    /** Generated Token Manager. */
    static public ACBasicTokenManager token_source;
    static SimpleCharStream jj_input_stream;
    /** Current token. */
    static public Token token;
    /** Next token. */
    static public Token jj_nt;
    static private int jj_ntk;
    static private int jj_gen;
    static final private int[] jj_la1 = new int[43];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static {
        jj_la1_init_0();
        jj_la1_init_1();
    }
    private static void jj_la1_init_0() {
        jj_la1_0 = new int[] {0x40,0x80,0x7c00,0x180000,0x8000000,0xfc00,0xfc00,0x0,0x8000000,0x0,0x0,0x7e00,0x8000000,0x7c00,0x1000000,0x40,0x270000,0x2000000,0x270000,0x270000,0x2000000,0x270000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180000,0x40000000,0x40000000,0x8000000,0x180000,0x400000,0x800000,0x40000000,0x8000000,0x180000,0x40000000,};
    }
    private static void jj_la1_init_1() {
        jj_la1_1 = new int[] {0x0,0x0,0x0,0x1e0000,0x0,0x0,0x0,0x1,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x10000,0x10000,0x0,0x10000,0x0,0xc00,0xc00,0x1f8,0x1f8,0x3000,0x3000,0xc000,0xc000,0x200,0x1f0002,0x2,0x2,0x0,0x1f0202,0x0,0x0,0x0,0x0,0x1f0202,0x3,};
    }

    /** Constructor with InputStream. */
    public ACBasic(java.io.InputStream stream) {
        this(stream, null);
    }
    /** Constructor with InputStream and supplied encoding */
    public ACBasic(java.io.InputStream stream, String encoding) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
        token_source = new ACBasicTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    static public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }
    /** Reinitialise. */
    static public void ReInit(java.io.InputStream stream, String encoding) {
        try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    }

    /** Constructor. */
    public ACBasic(java.io.Reader stream) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ACBasicTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    static public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    }

    /** Constructor with generated Token Manager. */
    public ACBasic(ACBasicTokenManager tm) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(ACBasicTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    }

    static private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /** Get the next Token. */
    static final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /** Get the specific Token. */
    static final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    static private int jj_ntk() {
        if ((jj_nt=token.next) == null)
            return (jj_ntk = (token.next=token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    static private int[] jj_expentry;
    static private int jj_kind = -1;

    /** Generate ParseException. */
    static public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[56];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 43; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1<<j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1<<j)) != 0) {
                        la1tokens[32+j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 56; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /** Enable tracing. */
    static final public void enable_tracing() {
    }

    /** Disable tracing. */
    static final public void disable_tracing() {
    }

}
